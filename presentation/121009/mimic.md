author: IS3年 完動班 卜部、冨田、濱中、名取
title: Mimic architecture

# 完動?

The "fastest" implementation for CPU Ex.

## 「速さ」とはなにか

従来の CPU 実験: レイトレーサを高速に動作させること

私の CPU 実験: レイトレーサを動作させるプロダクトを**短期間で**作成すること

## 結果

本番アーキテクチャ設計開始から**10人日**で実機動作

## 1. ソースとの同一性および再現性

- 同一性: シミュレータとのビットレベルの同一性は確認
- OCaml との同一性は確認できず。 16384(128*128) ピクセル中 9 ピクセルがことなる
- - 最適化により演算回数が異なるため、FPU の実行回数がことなり、それによる誤差がことなる
- - OCaml は内部的に数値を double で扱うため、単精度 <-> 倍精度の変換誤差が生じる
- 再現性: 5回連続でおなじデータが出力された

## 2. 計測結果

コンパイラコード = ハンドコード: 110.26 s

## 3. min-rt.ml の変更

- true, false は削除
- xor はハードウェア実装
- 審判サーバとのコミュニケーションのため、0xaa の送信コードを追加

## CPU 仕様

- MIPS ベースの ISA。必要そうなものは入れているので、比較的コンパイラに自由度がある。
- マルチクロックサイクル(可変サイクル数)  
- - 整数演算: 4クロック
- - メモリ読み書き・FPU: 7クロック
- - ジャンプなど: 3クロック
- 66MHz(標準クロックでぴったり)
- 32bit CPU
- 32 本レジスタ * 2 (GPR, FPR)

## コンパイラ・ライブラリ

CPUExSolver2 を使用

- 命令セットのカスタマイズ性が足りなかったので管理方法を改善(ad-hoc)
- GUI が使いにくかったので XML 単体で扱いやすいように変更
- 32 bit CPU で動作しない問題を解消
- 成果は [tomykaira/CPUExSolver2 at config](https://github.com/tomykaira/cpuexsolver2/tree/config) で公開

今後は ExSolver を捨て、卜部が min-caml をもとに作成する。
最初は命令数が増えてしまうが、全体を把握したコンパイラができるので、仕様の確認やデバッグが容易になるだろう。

## シミュレータ・アセンブラ

CPUExSolver2 の生成したものを改造。

出来あいのはデバッグ能力に欠けるので、命令流、データ流のダンプコードを追加。

- 命令実行時に命令の内容
- レジスタ書き込み時に書込み先と内容
- メモリ書き込み時に書込み先と内容
- IO 命令実行時

同様のものを HDL シミュレータからデバッグ出力し、一致することを確認。

## CPU・FPU

フルスクラッチで作成。

- D. Harris, 『ディジタル回路の設計とコンピュータアーキテクチャ』 をもとに最低限の VHDL を記述
- マルチクロックサイクル用のデコーダを作る
- デコーダが必要とする部品をつくる(レジスタ、ALU、FPU、アドレス計算、etc.)  
  ハードウェア実験の資産を活用(FPU、RS232C、SRAM)
- FPGA に書きこむ
- 動く

Verilog と VHDL が混在。

- VHDL は vhdl_doctest で組み合わせ回路の検証ができる
- Verilog は記述力が高く、テストベンチや FPU などのモジュールに向く

# 「速さ」のために

アジャイル、XP のプラクティスを参考。

- イテレーティブな開発
- フィードバックループ
- テスト駆動開発

これらを実践した結果、レイトレは一発で実機動作。

## イテレーティブな開発

いきなり目標を目指さない。到達可能な地点を目指す。

問題を分割する。次の目標に到達できないことがわかったら、その間になにか飛び石を作ってみる。

- fib
- 行列計算
- マンデルブロ <= 用意されていなかったので自分で作った
- レイトレ

## イテレーションの価値

- いままで自分が作ったものが期待どおり動作することに確信が持てる
- わかりやすい成果を示せる(発表の時など)
- 進捗が測りやすい
- 一度に改善すべき機能の数、対処すべきバグの数が減るので対処しやすい

実際に、マンデルブロを実機動作させることで Queue の長さがたりないという分かりにくい問題に対処できた。

## フィードバックループ

正しい方向に進んでいるかを常に確認する。

- ソフトウェア実装、CPU シミュレータ
- 組み合わせ回路のテスト
- HDL シミュレータ
- 実機(ダンプコードあり)
- 実機(大会レギュレーション)

## フィードバックの情報量

「うごいた」はわかりやすいが、「うまく動かない」はわかりにくい。
**「なぜ動かないのか」は無限にある**から。

動かない場合は問題領域をできるかぎり縮小する。
問題領域に対して得ることのできるフィードバックの量が相対的に大きくなる。

ハードウェアのようにフィードバックの量に物理的制限が場合はとくに有効。
(実機からは実質 RS232C 出力しか得られない)

## ハードウェアデバッグの例

- マンデルブロの一部について出力が得られない(データが消える)
- どの領域が表示されないのか
- その領域を表示するコードだけ切り出してみたらどうか
- 一行ぶんならどうか
- 増やしていくとどうなるか

結果、送信バッファの Queue があふれていて、演算が速くすむ部分だけが消えていることがわかった。

## テスト駆動開発

実際にイテレーティブかつフィードバックを得ながら開発するガイドライン。

「テスト駆動開発」の定義はそれだけで議論になるが、ソフトウェア開発でとられる一般的なテスト駆動開発は困難。
「客観的基準により確信を得ながら進んでいく」というふうにざっくり解釈。

- 動作させたい部分が動作していることを保証できるプログラムを書く(まず手書きアセンブラ、それから ML)
- CPU シミュレータで目的が達成できることを確認する(Red)  
  自分のプログラム、シミュレータ、コンパイラ、アセンブラをデバッグしていることにもなる
- 回路を記述し、 HDL シミュレータで動作することを命令、ビットレベルで確認する(Green 1)  
  ふたつのシミュレータでまったくおなじ出力を出せるようにしておいて、diff すると便利  
  大規模な diff には GUI (ediff, p4merge など)が便利
- 実機に載せて動作することを確認する(Green 2)

# 今月の余興

- 生田さんから月一で余興やれとお達しが来たので
- CPU 高速化とかより余興のほうが好きなので

できるかぎりやります。

今月の余興: 自作 CPU でいろんなもの描いてみたよ

## マンデルブロ

![mandelbrot](mandelbrot.png)

40M 命令ぐらいでコンパイラのデバッグ、ハードウェアの仕上げにちょうどいいサイズ。

ソースコード: https://gist.github.com/3736635

## 花火

![hanabi](hanabi.jpg)

PS1 みたいって言われた……

しょぼいのはレイトレの仕様でオブジェクトが 40 個までしか置けないため。

## 花火2

![hanabi2](hanabi2.png)

あまりにショボかったので専用のプログラムを書いた。

ソースコード: https://gist.github.com/3836880

# 今後の予定

- 卜部: コンパイラを作る(長期目標)
- 冨田: あそぶ
- 濱中: シミュレータをリッチにして卜部を助ける
- 名取: FPU が仕様を満たしていることを確認する(短期目標: 来週報告できるはず)

## 線表?

    卜部: -------(コンパイラ)--------
    濱中: -(FPU)-
    名取: -(Sim)-

- マイルストーンがない
- 予定の依存関係がない
- 予定は未定

## 課題管理

明確なストーリーがないので、場当たり的に Github の Issue で管理する。

- 進捗を明確に把握する
- 変化に対応する
- コミュニケーションを記録としてのこす

github flow をベースに構築。

詳細: https://github.com/tomykaira/mips/blob/master/github.md

# まとめ

- ひとつの課題
- ことなる目標
- ことなる速さ

## くわしくは

[CPU 実験完動報告 - tomykaira makes love with codes](http://tomykaira.hatenablog.com/entry/2012/09/19/012014)

環境、流れ、作った/使ったツールに言及しているので実験で参考になるはず。

## 謝辞

- @atetubou さん
- @furaga さん
- 細川さん

